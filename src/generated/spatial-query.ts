// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { QueryType } from './query-type';
import { Vec3 } from './vec3';


export class SpatialQuery {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):SpatialQuery {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsSpatialQuery(bb:flatbuffers.ByteBuffer, obj?:SpatialQuery):SpatialQuery {
  return (obj || new SpatialQuery()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsSpatialQuery(bb:flatbuffers.ByteBuffer, obj?:SpatialQuery):SpatialQuery {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new SpatialQuery()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

queryType():QueryType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : QueryType.BOUNDING_BOX;
}

boxMin(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Vec3()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

boxMax(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new Vec3()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

center(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new Vec3()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

radius():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

origin(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new Vec3()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

direction(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new Vec3()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

maxDistance():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

k():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

entityTypes(index: number):string
entityTypes(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
entityTypes(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

entityTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

maxResults():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 1000;
}

static startSpatialQuery(builder:flatbuffers.Builder) {
  builder.startObject(11);
}

static addQueryType(builder:flatbuffers.Builder, queryType:QueryType) {
  builder.addFieldInt8(0, queryType, QueryType.BOUNDING_BOX);
}

static addBoxMin(builder:flatbuffers.Builder, boxMinOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, boxMinOffset, 0);
}

static addBoxMax(builder:flatbuffers.Builder, boxMaxOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, boxMaxOffset, 0);
}

static addCenter(builder:flatbuffers.Builder, centerOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, centerOffset, 0);
}

static addRadius(builder:flatbuffers.Builder, radius:number) {
  builder.addFieldFloat32(4, radius, 0.0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, originOffset, 0);
}

static addDirection(builder:flatbuffers.Builder, directionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, directionOffset, 0);
}

static addMaxDistance(builder:flatbuffers.Builder, maxDistance:number) {
  builder.addFieldFloat32(7, maxDistance, 0.0);
}

static addK(builder:flatbuffers.Builder, k:number) {
  builder.addFieldInt32(8, k, 0);
}

static addEntityTypes(builder:flatbuffers.Builder, entityTypesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, entityTypesOffset, 0);
}

static createEntityTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEntityTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addMaxResults(builder:flatbuffers.Builder, maxResults:number) {
  builder.addFieldInt32(10, maxResults, 1000);
}

static endSpatialQuery(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

}
